var tipuesearch = {"pages": [{'title': 'W1', 'text': '1 super computer 超級電腦 2 mainframe 伺服器主機 3 server 伺服器 (虛擬 實體) 4 pc=person computer 個人電腦 5 microcontroller 微控制器 6 mobile phone 手機 Port 埠號\xa0 DHCP動態網路位置 \n', 'tags': '', 'url': 'W1.html'}, {'title': 'W2', 'text': '\n IPv4 version 4 IP\xa0 \xa0 \xa0 \xa0 四個區段,用.隔開 \n IPv6 version 6 IP\xa0 \xa0 \xa0 \xa0 八個區段,用:隔開 \n \n \n [2001:288:6004:17::53]:3128\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0140.130.17.53:3128 \n [2001:288:6004:17::42]:3128\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0140.130.17.53:254(系gateway通道) \n [2001:288:6004:17::17]:3128\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0140.130.1.*(校主幹 ) \n [2001:288:6004:17::7]:3128 \n \n tcp/ip==trandmision control protocol/internet\xa0protocol \n inter-net==inter-national(國際) \n (網際,inter+networt) \n \n protocal\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 協定 \n trasmit\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 傳輸 \n data\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 資料 \n control\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 控制 \n version\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0版本(短時間) \n edition\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 版本(長時間) \n router\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0路由器 \n route\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 路徑 \n packet\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 封包 \n remote login\xa0 \xa0 遠端登入 \n micro\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0微\xa0 \xa0 \xa0 \n microscope\xa0 \xa0 \xa0顯微鏡\xa0\xa0 \n telescope\xa0 \xa0 \xa0 \xa0 望遠鏡 \n macro\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0巨(比原子(atom)大)\xa0 \xa0 \xa0 \xa0 \n atomic bomb\xa0 原子彈 中華電信\xa0 \xa0dns. server.\xa0 \xa0 dns==domain name server 符號名稱伺服器 \n \n \n \n \n \n \n', 'tags': '', 'url': 'W2.html'}, {'title': 'W6', 'text': 'portable obs \n google hangout meet \n streeming and recording \n 讓手機可以利用電腦熱點上網： \n 採用\xa0 https://www.tp-link.com/us/home-networking/usb-adapter/tl-wn725n/ \n 將此一 USB Wifi adapter 連接電腦後, 若網路為 IPv4 協定時, 可以透過"設定 -> 網路和網際網路 -> 行動熱點", 選擇開啟並編輯"網路名稱與網路密碼"後, 讓至多 8 台手機透過熱點連線上網。 \n 但是因為目前 Windows 10 並 未提供 IPv6 網路協定下的網路熱點功能 , 因此在純 IPv6 網路協定下無法使用"行動熱點"服務。 \n \n 利用手機鏡頭當作 webcam: \n Android: \xa0 https://www.digitalcitizen.life/turn-android-smartphone-webcam-windows \xa0 iPhone: \xa0 https://www.makeuseof.com/tag/use-your-iphone-as-a-webcam-heres-how-ios/ \xa0 \n \n 需要 clone 個人倉儲時： \n git clone --recurse-submodules 倉儲_url.git \n 例如:\xa0git clone --recurse-submodules \xa0 https://github.com/mdecourse/wcmj2020.git \n 現場直播的 audio 錄音設定 \n 在電腦輔助設計室進行直播時, 由於現場有擴音設備, 因此採用 OBS 串流至 Youtube 的最佳收音並非從 Webcam 的麥克風, 而是從擴音器以 audio outpu 連接到電腦的麥克風插槽, 然後將 OBS 的 audio 設定為從電腦的麥克風收音. \n', 'tags': '', 'url': 'W6.html'}, {'title': 'W7', 'text': 'grouping and meet. \n \n', 'tags': '', 'url': 'W7.html'}, {'title': 'W8', 'text': 'meeting\xa0 \xa0 \xa0 https://meet.google.com/zen- ewrh-zfy \xa0第三組 \xa0 2001:288:6004:17::53 2001:288:6004:17::42 2001:288:6004:17::17 2001:288:6004:17::4 "虛擬主機 不耐操 可以校外連接" \xa0 可能線上上課 組員: \xa0 50833104 組長 50833106 \xa0 50833113 \xa0 50833114 \xa0 50833116 \xa0 50833118 \xa0 50833120 \xa0 50833125 \xa0 50833140 50833141\xa0 group 3 \n', 'tags': '', 'url': 'W8.html'}, {'title': 'w9', 'text': '', 'tags': '', 'url': 'w9.html'}, {'title': '電腦軟硬體簡介：', 'text': '', 'tags': '', 'url': '電腦軟硬體簡介：.html'}, {'title': '電腦硬體設備介紹：', 'text': '\n 主機板：主機板的功能主要在承戴其插卡，所有電腦裡的東西都會接到主機板 ，它們之間要相互的傳資料也是經過主機板，之後再傳到對方，簡單的來說，它就像一個轉運站一樣。 \n 顯示卡 (VGA) ：顯示卡在電腦中主要作用就是程式運行時根據 CPU 提共的指令和有關數據，轉換成顯示器能夠接受的文字和圖形顯示信號後通過螢幕顯示出來，簡單來說，就是把電腦計算出來的文字與圖形表現在顯示器上。 \n 中央處理器 (CPU) ：又稱為電腦的心臟，而 CPU 主要工作是算術、運輯運算，解讀電腦內的每個指令來控制電腦的運作。 \n 記憶體 (RAM) ：記憶體的主要功用是暫存資料，當它被使用時，系統可以從 RAM 上存取資料，而且需要電力來維持它的記憶，所以記憶體可以說是電腦系統中最佳倉儲管理員。 \n \n', 'tags': '', 'url': '電腦硬體設備介紹：.html'}, {'title': '電腦軟體設備介紹：', 'text': '則是看不到或觸摸不到的程式，由許多特殊安排的指令組織而成，分為兩種： \n \n 系統軟體：作業系統，語言編譯器及公用程式，尚有 DOS 、 Windows95/98/2000/Me 、 Unix 、 ... 等等。 \n 應用軟體：如 Word 文書處裡、 ExceI 電子式算表、 PowerPoint 簡報軟體、 Photoshop 影像處理、 Flash 像量動畫、遊戲軟體 ..... 等。 \n \n \n', 'tags': '', 'url': '電腦軟體設備介紹：.html'}, {'title': '網路架構與設定簡介：', 'text': 'win10 電腦網路設定說明： \n 步驟1  同時按【WIN鍵+X鍵】→選擇【控制台】。 \n 步驟2  點選【 網路 和網際 網路 】。 \n 步驟3  選擇【 網路 和共用中心】。 \n 步驟4  選擇【設定新的連線或 網路 】。 \n 步驟5  連線完成後即可上網。 \n 步驟6  選擇【關閉】完成設定動作。 \n 步驟7  之後若要連線，請點選【寬頻連線】即可上網。 \n', 'tags': '', 'url': '網路架構與設定簡介：.html'}, {'title': '網際網路：', 'text': '網際網路是指 20世紀 末期興起 電腦網路 與電腦網路之間所串連成的龐大 網路 系統。這些網路以一些標準的 網路協定 相連。它是由從地方到全球範圍內幾百萬個私人、 學術界 、企業和政府的網路所構成，透過 電子 ， 無線 和 光纖網路技術 等等一系列廣泛的技術聯繫在一起。網際網路承載範圍廣泛的資訊資源和服務，例如相互關聯的 超文字 檔案，還有 全球資訊網 （WWW）的應用， 電子郵件 ， 通話 ，以及 檔案分享 服務。 \n 網際網路的起源可以追溯到1960年代 美國聯邦政府 委託進行的一項研究，目的是建立容錯與電腦網路的通信。網際網路的前身 ARPANET 最初在1980年代作為區域學術和軍事網路連接的骨幹。1980年代， NSFNET 成為新的骨幹而得到資助，以及其他商業化擴展得到了私人資助，導致了全世界網路技術的發展，以及許多網路的合併。到1990年代初，商業網路和企業之間的連接標誌著向現代網際網路的過渡。儘管網際網路在1980年代被學術界廣泛使用 ， 但商業化的服務和技術融入了現代每個人的生活 。 \n', 'tags': '', 'url': '網際網路：.html'}, {'title': 'W10', 'text': 'Public key 公開密要加密 \n Cryptography 編碼學 \n SSH 安全編碼機制 \n Putty：FREE SSH FOR WINDOW \n FREE SSH FOR WINDOW \n 設置：移動滑鼠 \n \n \n Private key \n', 'tags': '', 'url': 'W10.html'}, {'title': 'W12-W13', 'text': 'W12 \n Leo Editor 與 Pelican blog 使用說明影片 \n W13 \n Pelican Blog 內容與 Google Blogger 同步 \n W13\xa0 利用 Leo Editor 按鈕處理同步說明影片 \n 教學影片-2 \n 教學影片-3 \n 利用 Windows 10 設定 -> 選擇預設網頁瀏覽器, 使用 Google Chrome 作為預設瀏覽器. \n 隨身程式系統必須安裝\xa0 google-api-python-client 與 oauth2client pip install google-api-python-client oauth2client OAuth 2.0 client IDs 程式類別可以選擇 Desktop app 使用者完成 client_secrets.json 設定後, 必須將檔案存在倉儲目錄外部 \n 將 client_secrets.json 轉為 credential_token.dat 的程式: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n \n \n \n @language   python \n # https://developers.google.com/blogger/docs/3.0/using \n # under Mac command + b to execute \n import   pickle \n import   os \n from   googleapiclient.discovery  import   build \n from   google_auth_oauthlib.flow  import   InstalledAppFlow \n \xa0 \n \xa0 \n SCOPES  =   [ \'https://www.googleapis.com/auth/blogger\' , ] \n \xa0 \n # we check if the file tBo store the credentials exists \n if   not   os.path.exists( \'./../../yen_gm_blogger_token.dat\' ): \n \xa0 \n \xa0\xa0\xa0\xa0 flow  =   InstalledAppFlow.from_client_secrets_file( \'./../../yen_gm_blogger_secrets.json\' , SCOPES) \n \xa0\xa0\xa0\xa0 credentials  =   flow.run_local_server() \n \xa0 \n \xa0\xa0\xa0\xa0 with  open ( \'./../../yen_gm_blogger_token.dat\' ,  \'wb\' ) as credentials_dat: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pickle.dump(credentials, credentials_dat) \n else : \n \xa0\xa0\xa0\xa0 with  open ( \'./../../yen_gm_blogger_token.dat\' ,  \'rb\' ) as credentials_dat: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 credentials  =   pickle.load(credentials_dat) \n service  =   build( \'blogger\' ,  \'v3\' , credentials = credentials) \n g.es(service) \n \n \n \n \n \n \n \n add_to_blogger 按鈕內容: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n \n \n \n @language   python \n from   markdown  import   markdown \n from   oauth2client  import   client \n #from googleapiclient import sample_tools \n import   os \n # 配合使用 credential token \n import   pickle \n from   googleapiclient.discovery  import   build \n #from google_auth_oauthlib.flow import InstalledAppFlow \n #from google.auth.transport.requests import Request \n \xa0 \n os.environ[ \'TZ\' ]  =   \'Asia/Taipei\' \n with  open ( \'./../../blogger_credentials.dat\' ,  \'rb\' ) as credentials_dat: \n \xa0\xa0\xa0\xa0 credentials  =   pickle.load(credentials_dat) \n service  =   build( \'blogger\' ,  \'v3\' , credentials = credentials) \n \xa0 \n def   get_cat_tag_content(data): \n \xa0\xa0\xa0\xa0 # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 --- \n \xa0\xa0\xa0\xa0 # 用跳行符號分割 \n \xa0\xa0\xa0\xa0 data_list  =   data.split( "\\n" ) \n \xa0\xa0\xa0\xa0 #第 2 行為 title \n \xa0\xa0\xa0\xa0 title =   data_list[ 1 ] \n \xa0\xa0\xa0\xa0 #第 4 行為 category \n \xa0\xa0\xa0\xa0 category  =   data_list[ 3 ] \n \xa0\xa0\xa0\xa0 #第 5 行為 tags \n \xa0\xa0\xa0\xa0 tags  =   data_list[ 4 ] \n \xa0\xa0\xa0\xa0 # 有多項資料的 content 型別為數列 \n \xa0\xa0\xa0\xa0 # 再將第 9 行之後的資料數列串回成以跳行隔開的資料 \n \xa0\xa0\xa0\xa0 content  =   "\\n" .join(data_list[ 8 :]) \n \xa0\xa0\xa0\xa0 # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 <!--more--> \n \xa0\xa0\xa0\xa0 content  =   content.replace( \'<!-- PELICAN_END_SUMMARY -->\' ,  \'<!--more-->\' ) \n \xa0\xa0\xa0\xa0 # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 \n \xa0\xa0\xa0\xa0 #content = content.replace(\'~~~python\', \'[code lang="python"]\') \n \xa0\xa0\xa0\xa0 #content = content.replace(\'~~~\', \'[/code]\') \n \xa0\xa0\xa0\xa0 return   title, category, tags, content \n \xa0 \n # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 \n # p.h 為 @clean filename.md \n # 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案 \n md_filename  =   p.h.split( " " )[ 1 ] \n with  open (md_filename,  \'r\' , encoding = "utf-8" ) as content_file: \n \xa0\xa0\xa0\xa0 md_content  =   content_file.read() \n # title_str, category_str, tags_str, content = get_cat_tag_content(p.b) \n title_str, category_str, tags_str, content  =   get_cat_tag_content(md_content) \n category  =   category_str.split( ":" )[ 1 ] \n tags  =   tags_str.split( ":" )[ 1 ].split( "," ) \n tags.append(category) \n # title 是一個單獨的字串 \n title  =   title_str.split( ":" )[ 1 ] \n # 將 markdown 格式 content 轉為 html \n content  =   markdown(content) \n # 以下處理 content 的 <h2> 標題 \n content  =   content.replace( "<h2>" ,  "<h2><font size=\'4\'>" ) \n content  =   content.replace( "</h2>" ,  "</font></h2>" ) \n # g.es(content) \n \xa0 \n try : \n \xa0\xa0\xa0\xa0 \'\'\' \n \xa0\xa0\xa0\xa0 users = service.users() \n \xa0\xa0\xa0\xa0 # 取得使用者 profile 資料 \n \xa0\xa0\xa0\xa0 user = users.get(userId=\'self\').execute() \n \xa0\xa0\xa0\xa0 print(\'網誌名稱: %s\' % user[\'displayName\']) \n \xa0\xa0\xa0\xa0 \'\'\' \n \xa0\xa0\xa0\xa0 blogs  =   service.blogs() \n \xa0\xa0\xa0\xa0 # 取得使用者所建立網誌名稱 \n \xa0\xa0\xa0\xa0 blogs  =   blogs.listByUser(userId = \'self\' ).execute() \n \xa0\xa0\xa0\xa0 # post_id is now blogs["items"][0]["id"] \n \xa0\xa0\xa0\xa0 blog_id  =   blogs[ "items" ][ 0 ][ "id" ] \n \xa0\xa0\xa0\xa0 #for blog in blogs[\'items\']: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 #print(blog[\'name\'], blog[\'url\']) \n \xa0\xa0\xa0\xa0 posts  =   service.posts() \n \xa0\xa0\xa0\xa0 # 新增網誌 post 時, 需要 post_id \n \xa0\xa0\xa0\xa0 body  =   { \n \xa0\xa0\xa0\xa0 "kind" :  "blogger#post" , \n \xa0\xa0\xa0\xa0 "id" : blog_id, \n \xa0\xa0\xa0\xa0 "title" : title, \n \xa0\xa0\xa0\xa0 # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容 \n \xa0\xa0\xa0\xa0 "content" : content, \n \xa0\xa0\xa0\xa0 "labels" : tags \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 insert  =   posts.insert(blogId = blog_id, body = body) \n \xa0\xa0\xa0\xa0 posts_doc  =   insert.execute() \n \xa0\xa0\xa0\xa0 post_id  =   posts_doc[ "id" ] \n \xa0\xa0\xa0\xa0 #print(posts_doc) \n \xa0\xa0\xa0\xa0 # 改用 credential token 後不會產生 blogger.dat \n \xa0\xa0\xa0\xa0 #os.remove("blogger.dat") \n \xa0\xa0\xa0\xa0 # 利用最後的 child 節點來儲存 post_id \n \xa0\xa0\xa0\xa0 to_save_post_id  =   p.insertAsLastChild()\xa0\xa0  \n \xa0\xa0\xa0\xa0 # 改為內文為空的節點, id 直接標在 head 標題  \n \xa0\xa0\xa0\xa0 to_save_post_id.b  =   "" \n \xa0\xa0\xa0\xa0 to_save_post_id.h  =   post_id \n \xa0\xa0\xa0\xa0 # 因為新增節點, commander 必須 redraw \n \xa0\xa0\xa0\xa0 c.redraw() \n \xa0\xa0\xa0\xa0 g.es( "post_id 為" , post_id) \n \xa0\xa0\xa0\xa0 g.es( "已經將資料送往 Blogger!" ) \n except (client.AccessTokenRefreshError): \n \xa0\xa0\xa0\xa0 g.es( "error" ) \n \n \n \n \n \n \n \n edit_to_blogger 按鈕內容: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n \n \n \n @language   python \n from   markdown  import   markdown \n from   oauth2client  import   client \n #from googleapiclient import sample_tools \n import   os \n # 配合使用 credential token \n import   pickle \n from   googleapiclient.discovery  import   build \n #from google_auth_oauthlib.flow import InstalledAppFlow \n #from google.auth.transport.requests import Request \n \xa0 \n os.environ[ \'TZ\' ]  =   \'Asia/Taipei\' \n with  open ( \'./../../blogger_credentials.dat\' ,  \'rb\' ) as credentials_dat: \n \xa0\xa0\xa0\xa0 credentials  =   pickle.load(credentials_dat) \n service  =   build( \'blogger\' ,  \'v3\' , credentials = credentials) \n \xa0 \n def   get_cat_tag_content(data): \n \xa0\xa0\xa0\xa0 # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 --- \n \xa0\xa0\xa0\xa0 # 用跳行符號分割 \n \xa0\xa0\xa0\xa0 data_list  =   data.split( "\\n" ) \n \xa0\xa0\xa0\xa0 #第 2 行為 title \n \xa0\xa0\xa0\xa0 title =   data_list[ 1 ] \n \xa0\xa0\xa0\xa0 #第 4 行為 category \n \xa0\xa0\xa0\xa0 category  =   data_list[ 3 ] \n \xa0\xa0\xa0\xa0 #第 5 行為 tags \n \xa0\xa0\xa0\xa0 tags  =   data_list[ 4 ] \n \xa0\xa0\xa0\xa0 # 有多項資料的 content 型別為數列 \n \xa0\xa0\xa0\xa0 # 再將第 9 行之後的資料數列串回成以跳行隔開的資料 \n \xa0\xa0\xa0\xa0 content  =   "\\n" .join(data_list[ 8 :]) \n \xa0\xa0\xa0\xa0 # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 <!--more--> \n \xa0\xa0\xa0\xa0 content  =   content.replace( \'<!-- PELICAN_END_SUMMARY -->\' ,  \'<!--more-->\' ) \n \xa0\xa0\xa0\xa0 # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 \n \xa0\xa0\xa0\xa0 #content = content.replace(\'~~~python\', \'[code lang="python"]\') \n \xa0\xa0\xa0\xa0 #content = content.replace(\'~~~\', \'[/code]\') \n \xa0\xa0\xa0\xa0 return   title, category, tags, content \n \xa0 \n # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 \n # p.h 為 @clean filename.md \n # 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案 \n md_filename  =   p.h.split( " " )[ 1 ] \n with  open (md_filename,  \'r\' , encoding = "utf-8" ) as content_file: \n \xa0\xa0\xa0\xa0 md_content  =   content_file.read() \n # title_str, category_str, tags_str, content = get_cat_tag_content(p.b) \n title_str, category_str, tags_str, content  =   get_cat_tag_content(md_content) \n category  =   category_str.split( ":" )[ 1 ] \n tags  =   tags_str.split( ":" )[ 1 ].split( "," ) \n tags.append(category) \n # title 是一個單獨的字串 \n title  =   title_str.split( ":" )[ 1 ] \n # 將 markdown 格式 content 轉為 html \n content  =   markdown(content) \n # 以下處理 content 的 <h2> 標題 \n content  =   content.replace( "<h2>" ,  "<h2><font size=\'4\'>" ) \n content  =   content.replace( "</h2>" ,  "</font></h2>" ) \n # g.es(content) \n \xa0 \n try : \n \xa0\xa0\xa0\xa0 blogs  =   service.blogs() \n \xa0\xa0\xa0\xa0 # 取得使用者所建立網誌名稱 \n \xa0\xa0\xa0\xa0 blogs  =   blogs.listByUser(userId = \'self\' ).execute() \n \xa0\xa0\xa0\xa0 blog_id  =   blogs[ "items" ][ 0 ][ "id" ] \n \xa0\xa0\xa0\xa0 # 設法取得原 post 的 id \n \xa0\xa0\xa0\xa0 postid_outline  =   p.getLastChild() \n \xa0\xa0\xa0\xa0 # 直接從標題取得 post 的 id 號碼 \n \xa0\xa0\xa0\xa0 post_id  =   postid_outline.h \n \xa0\xa0\xa0\xa0 posts  =   service.posts() \n \xa0\xa0\xa0\xa0 # 更新網誌文章時的 body \n \xa0\xa0\xa0\xa0 body  =   { \n \xa0\xa0\xa0\xa0 "kind" :  "blogger#post" , \n \xa0\xa0\xa0\xa0 "title" : title, \n \xa0\xa0\xa0\xa0 "content" : content \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 # need to save postId to outline head \n \xa0\xa0\xa0\xa0 update  =   posts.update(blogId = blog_id, postId = post_id, body = body, publish = True ) \n \xa0\xa0\xa0\xa0 update_doc  =   update.execute() \n \xa0\xa0\xa0\xa0 # 使用 credential token 後, 無需刪除 blogger.dat \n \xa0\xa0\xa0\xa0 #os.remove("blogger.dat") \n \xa0\xa0\xa0\xa0 g.es( "post_id 為" , post_id) \n \xa0\xa0\xa0\xa0 g.es( "已經將更新資料送往 Blogger!" ) \n except (client.AccessTokenRefreshError): \n \xa0\xa0\xa0\xa0 g.es( "error" ) \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'W12-W13.html'}, {'title': 'W14', 'text': '直接在操作系統建立網際內容管理合用系統 \n Windows 10 64 位元操作系統 \n 安裝 Python 3.8.3 與 pip \n 至\xa0 https://www.python.org/downloads/windows/ \xa0 \n 下載 Python 3.8.3 \xa0 Windows x86-64 executable installer \n 可以直接選擇安裝 pip 與所有選項內容 \n 安裝 Git \n 利用\xa0 64-bit Git for Windows Setup \xa0安裝 Git 工具. \n 安裝 CMSiMDE 所需模組 \n 利用 cmd 開啟命令列視窗, 以 pip 安裝 flask flask_cors lxml bs4 markdown pelican leo 等模組 \n pip install\xa0 \xa0flask flask_cors lxml bs4 markdown pelican leo \n Ubuntu 20.04 操作系統 (請下載 \xa0 W12 Virtualbox 虛擬主機檔案 ) \n Ubuntu 20.04 同時存在 Python 2.7 與 Python 3.8.2,\xa0 CMSiMDE 只相容於 Python 3.8.2, 因此啟動指令必須使用: \n python3 wsgi.py \n 與\xa0 \n pip3 install\xa0 \xa0flask flask_cors lxml bs4 markdown pelican leo \n Mac OS X 操作系統 \n 與 Ubuntu 20.04 類似。 \n \n \n', 'tags': '', 'url': 'W14.html'}]};